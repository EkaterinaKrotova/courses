## Домашнее задание

### Описание

Есть программный продукт, который состоит из backend и frontend приложений. Backend зависит от нереляционной базы данных (NoSQL) под названием MongoDB. Frontend в свою очередь обращается к backend-приложению, чтобы тот подтянул данные из MongoDB и отобразил на веб-страничке.

### Задания

1. Написать `Dockerfile` для backend и frontend приложений (или, иными словами, "докеризировать" приложения) по хорошим практикам, которые мы проходили в течение всех занятий, с учётом оптимизации инструкций и слоёв в Dockerfile, а также с учётом оптимизации размера итогового образа. Для backend и frontend приложений пробросить статические порты с хоста в контейнер, а для MongoDB пробросить случайный порт.
2. Для frontend приложения сделать так, чтобы переменные окружения можно было изменять в рантайме (как это работает для backend приложения по умолчанию), а не при сборке приложения. Чтобы было проще, вот две ссылки с описанием того, как это можно реализовать: [click](https://rakhayyat.medium.com/vuejs-on-docker-environment-specific-settings-daf2de660b9) и [click](https://pumpingco.de/blog/environment-variables-angular-docker/). Если у вас получится пройти этот этап, то будет плюсик в карму. Если же нет, то пусть переменные окружения передаются хотя бы при сборке приложения.
3. Написать `docker-compose.yml` файл и описать в нём всё как для запуска приложений, так и для их сборки, дабы после выполнения команды `docker-compose up -d` всё собралось, запустилось приложение и можно было бы посмотреть работает ли оно или нет. Повторяющиеся элементы в файле docker-compose.yml, если таковые присутствуют, вынести в отдельный блок (например, `x-common`), чтобы переиспользовать его при необходимости в нескольких сервисах.
4. MongoDB должен быть stateful, т.е. сохранять своё состояние и данные в базе после того, как вы остановили или удалили ваш контейнер.
5. После ввода команды `docker-compose up -d` backend приложение должно сначала дождаться запуска MongoDB, и только после этого backend приложение должно начать запускаться. Сделать это можно абсолютно разными способами: [Dockerize](https://github.com/jwilder/dockerize) , [wait-for-it bash script](https://github.com/vishnubob/wait-for-it) , [wait-for shell script](https://github.com/eficode/wait-for), Linux команды (`nc`, `wget`, ...). Какой способ выбрать - решать вам, ибо в нашем случае они все будут актуальны.
6. Что вы должны получить по итогу: работающий в Docker-контейнерах программный продукт с данными, которые подтягиваются из MongoDB, который выглядит как на первом рисунке при переходе на frontend приложение. Помимо добавления данных, редактирование и удаление данных тоже должно работать. При этом, в консоли разработчика в браузере не должно быть выделенной красным строки, как это показано на втором рисунке. На третьем рисунке показано, что данные, отображаемые на фронтэнде действительно есть в коллекции базы в MongoDB. При удалении и редактировании данных на фронтэнде, эти данные должны мгновенно измениться в базе. Вы это можете проверить используя командную строку MongoDB.

### Итого

Хоть эти приложения не столь большие по функционалу, но они отражают практически реальный проект в рамках того, что мы проходили в разделе Docker, с которым мы можете в перспективе столкнуться. Именно поэтому его будет очень полезно сделать.
Если вдруг что-то забыл учесть или у вас есть какие-то вопросы - смело пишите в личку.

### Проверка задания

Прислать в личку архив с итоговым проектом, а также прислать скриншоты, что данные в MongoDB есть и они действительно совпадают с тем, что отображает на своём UI frontend приложение.

### Переменные окружения

Backend:
- `HOST` (пример значения: `0.0.0.0`)
- `PORT` (пример значения: `3000`)
- `DB_HOST` (пример значения: `127.0.0.1`)
- `DB_PORT` (пример значения: `27017`)
- `DB_NAME` (пример значения: `books_db`)
- `DB_COLLECTION` (пример значения: `mybooks`)

Frontend:
- `BACKEND_HOST` (пример значения: `localhost`)
- `BACKEND_PORT` (пример значения: `3000`)
- `PROD_STATE` (пример значения: `true`)
